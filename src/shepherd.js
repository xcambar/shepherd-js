/**
 *
 * Copyright (c) 2012, Xavier Cambar
 * Licensed under the MIT License (see LICENSE for details)
 *
 * Sources of inspiration (among others)
 * @see http://wiki.ecmascript.org/doku.php?id=harmony:modules for parsing and use case reference
 * @see http://addyosmani.com/writing-modular-js/
 */
(function (me, parser, when, flavourConfig, undefined) {
    if (typeof parser.parse !== 'function') {
        throw 'No parser provided.';
    }
    function is (obj, type) { //Thanks Underscore ;)
        return Object.prototype.toString.call(obj).toLowerCase() == '[object ' + type.toLowerCase() + ']';
    }
    function flavour (name, args) {
        if (name in flavourConfig) {
            return flavourConfig[name].apply({is: is}, args);
        }
        return null;
    }
    var modules = {},
        _errModules = null,
        _isServer = typeof window == 'undefined',
        _runInTag;
    //
    // Native plugins
    //
    var _plugins = {
        'modularize': function modularizePlugin (vars) {
            function fn (globalVar) {
                if (!me.hasOwnProperty(globalVar)) {
                    return 'No global "' + globalVar + '"';
                }
                modules[globalVar] = me[globalVar];
                return true;
            }
            if (is(vars, 'array')) {
                for (var i = 0; i < vars.length; i++) {
                    fn(vars[i]);
                }
            } else {
                fn(vars);
            }
        },
        'noGlobal': function noGlobalPlugin (vars) {
            var fn = function (globalVar) {
                if (!me.hasOwnProperty(globalVar)) {
                    return 'No global "' + globalVar + '"';
                }
                delete me[globalVar];
                return true;
            };
            if (is(vars, 'array')) {
                for (var i = 0; i < vars.length; i++) {
                    fn(vars[i]);
                }
            } else {
                fn(vars);
            }
        }
    };
    
    //
    //
    // Module declaration parser
    //
    //
    
    /**
     * Parses the module declaration and prepares the execution context of the module
     * @param {String} The contents of the file to be parsed
     * @return {Object|String} Returns the module's evaluated execution context or an error string
     */
    function parse (declaration, conf) {
        try {
            var module = parser.parse(declaration);
            return module;
        } catch (e) {
            return 'Invalid declaration \n' + e.message + '\nDeclaration: ' + declaration;
        }
    }
    
    /**
     * This function is in charge of setting all the modules exports in the memory.
     * @param {Object} module The module itself. Contains all the values exported by the module
     * @param {String} src The source file where the module is defined
     * @param {String} name The name of the module
     */
    function _registerModule (module, src, name) {
        var existingMod;
        if (src) {
            existingMod = modules[src];
            if (existingMod && !when.isPromise(existingMod)) {
                return 'Duplicating module ' + src;
            }
            modules[src] = module;
        }
        if (name) {
            existingMod = modules[name];
            if (existingMod && !when.isPromise(existingMod)) {
                return 'Duplicating module ' + name;
            }
            modules[name] = module;
        }
    }

    /**
     * Loads a module in its own wrapper function
     * The module is ocnsideref as fully loaded, dependencies included.
     * When using a loader wrapper, we are out of this scope, as dependencies are likely yet to be loaded.
     * The interface must be updated to reflect the need of one more level of async.
     * @TODO Change the process when using AMD (current example)
     * @param {Object} moduleConf The module configuration
     * @param {String|Function} contents The function or its contents to be run
     */
    function loadModule (moduleConf, contents) {
        !moduleConf && (moduleConf = {});
        moduleConf.imports = moduleConf.imports || {};
        var module = flavour('loadModule', [moduleConf, contents, _runInTag]);
        var _err = _registerModule(module, moduleConf._internals.src, moduleConf.name);
        return _err || module;
    }
    
    /**
     * Turns the configuration of the module into an actual module. Recursively loads and applies dependencies
     * @param {Object} conf The configuration generated by the parser
     */
    function applyConfiguration (conf) {
        var moduleConf = {};
        var confPromises = [];

        moduleConf._internals = conf._internals;

        function importLoader (declaration) {
            moduleConf.imports = moduleConf.imports || {};
            var _dep = modules[declaration.from.path];
            if (_dep) {
                if (when.isPromise(_dep)) {
                    _dep.then(function (module) {
                        for (var i = 0, _l = declaration.vars.length; i < _l; i++) {
                            var _importName = declaration.vars[i];
                            moduleConf.imports[_importName] = module[_importName];
                        }
                    });
                    confPromises.push(_dep);
                } else {
                    for (var i = 0, _l = declaration.vars.length; i < _l; i++) {
                        var _importName = declaration.vars[i];
                        moduleConf.imports[_importName] = _dep[_importName];
                    }
                }
            } else {
                var _p = _module(
                    declaration.from.path,
                    function (module) {
                        for (var i = 0, _l = declaration.vars.length; i < _l; i++) {
                            var _importName = declaration.vars[i];
                            moduleConf.imports[_importName] = module[_importName];
                        }
                    }
                );
                //@TODO These 2 expressions are probably (clearly?) the signal for a refactoring need
                if (!modules[declaration.from.path]) {
                    modules[declaration.from.path] = _p;
                }
                if (when.isPromise(modules[declaration.from.path])) {
                    confPromises.push(_p);
                }
            }

        }

        function exportLoader (declaration) { //@TODO Handle export renaming
            for (var i = 0, _l = declaration.length; i < _l; i++) {
                moduleConf.exports = moduleConf.exports || [];
                moduleConf.exports.push({src: declaration[i], dest: declaration[i]});
            }
        }

        function moduleLoader (declaration) {
            //@TODO Make sure of the availability of the module, if it is loadING and not loaded
            // if (modules.hasOwnProperty(declaration.id)) { //Module has already been declared
            //     return;
            // }
            // modules[declaration.id] = undefined;
            moduleConf.name = conf.decl.id;
            if (declaration.expressions) {
                for (var i = 0, _l = declaration.expressions.length; i < _l; i++) {
                    var expr = declaration.expressions[i];
                    if (expr.type === 'export') {
                        exportLoader(expr.decl);
                    } else if (expr.type === 'import') {
                        importLoader(expr.decl);
                    } else if (expr.type === 'module') {
                        moduleLoader(expr.decl);
                    }
                }
            } else { //This is a module reference
                moduleConf.imports = moduleConf.imports || {};
                var ref = declaration.path || declaration.src || declaration.id;
                var _mod = modules[ref];
                
                if (_mod) { //The module has already been loaded
                    if (when.isPromise(_mod)) {
                        _mod.then(function (module) {
                            moduleConf.imports[declaration.id] = module;
                            return module;
                        });
                        confPromises.push(_mod);
                    } else {
                        moduleConf.imports[declaration.id] = _mod;
                    }
                } else if (declaration.path) {
                    var _p = _module(
                        declaration.path,
                        function (module) {
                            moduleConf.imports[declaration.id] = module;
                            return moduleConf;
                        }
                    );
                    //@TODO These 2 expressions are probably (clearly?) the signal for a refactoring need
                    if (!modules[declaration.path]) {
                        modules[declaration.path] = _p;
                    }
                    if (when.isPromise(modules[declaration.path])) {
                        confPromises.push(_p);
                    }
                } else {
                    var _dep = flavour('loadModuleReferenceBySource', [declaration.src]);
                    moduleConf.imports[declaration.id] = _dep;
                }
            }
        }

        if (conf.type === 'module') {
            moduleConf.name = conf.decl.id;
            moduleLoader(conf.decl);
        } else if (conf.type === 'export') {
            exportLoader(conf.decl);
        } else if (conf.type === 'import') {
            importLoader(conf.decl);
        }
        var defer = when.all(confPromises).then(
            function () {
                return moduleConf;
            }, function () {
                return new Error('Error while loading ' + moduleConf._internals.src);
            }
        );
        return defer;
    }
    
    function _moduleSrc (conf) {
        var defer = when.defer(),
            moduleConf = conf || {},
            rawText = conf.contents ? conf.contents : '',
            declaration = '',
            module;
        var comments = rawText.match(/\s*\/\/\s*s6d([\s\S]*?)\/\/\s*-s6d/m);
        if (!comments) {
            module = loadModule({_internals: {src: conf.src}}, rawText);
            if (typeof module === 'string') {
                return defer.reject(module);
            }
            return defer.resolve(module);
        }
        // @TODO Enhance: Only a single declaration is allowed per file, as the first comment
        var split = comments[1].split("\n");
        for (var j = 0, _l2 = split.length; j < _l2; j++) {
            declaration += split[j].trim();
        }
        if (declaration.length) {
            moduleConf = parse(declaration, moduleConf);
            if (is(moduleConf, 'string')) {
                defer.reject(moduleConf);
            } else {
                //@TODO Allow multiple declarations
                var usedConf = moduleConf[0];
                usedConf._internals = {src: conf.src, contents: rawText};
                when(applyConfiguration(usedConf)).then(
                    function (moduleConf) {
                        module = loadModule(moduleConf, moduleConf._internals.contents.replace(comments[0], ''));
                        defer.resolve(module);
                        return module;
                    },
                    function (e) {
                        defer.reject(e);
                        return e;
                    }
                );
            }
        } else {
            module = loadModule({_internals: {src: conf.src}}, rawText);
            defer.resolve(module);
            return module;
        }
        return defer.promise || defer;
    }
        
    /**
     * Retrieves the file corresponding to the module and declares it
     * @return {Promise}
     */
    function _module (moduleSrc, callback, errorFn) {
        if (modules.hasOwnProperty(moduleSrc)) {
            if (!when.isPromise(modules[moduleSrc])) {
                callback(modules[moduleSrc]);
            }
            return modules[moduleSrc];
        }
        function _error (msg) {
            _errModules = _errModules || [];
            _errModules.indexOf(moduleSrc) === -1 && _errModules.push(moduleSrc);
            if (is(errorFn, 'function')) {
                errorFn();
            } else {
                console && console.error('(' + moduleSrc + ') ' + msg);
                return new Error( '(' + moduleSrc + ') ' + msg);
            }
        }
        _error.origFn = errorFn;
        
        var modulePromise = when.defer();
        modulePromise.then(callback, _error);
        
        var moduleConf = is(moduleSrc, 'string') ?  {src: moduleSrc} : moduleSrc;
        var uri = is(moduleSrc, 'string') ? moduleSrc : moduleSrc.name;
        if (uri) {
            var _contextReturn = flavour('retrieveFileContents', [uri, moduleConf, _moduleSrc, modulePromise]);
            return _contextReturn.promise || _contextReturn;
        } else {
            if (is(moduleSrc, 'object')) {
                when(_moduleSrc(moduleSrc)).then(
                    function (conf) {
                        modulePromise.resolve(conf);
                        return conf;
                    }, function (msg) {
                        modulePromise.reject(msg);
                    }
                );
            }
            return modulePromise;
        }
    }
    
    /**
     * Parses the configuration objects
     */
    function initConfig (confs) {
        for (var i = 0; i < confs.length; i++) {
            var confStr = confs[i];
            var conf;
            if (is(confStr, 'object')) {
                conf = confStr;
            } else if (is(JSON, 'object')) {
                conf = JSON.parse(confStr);
            } else {
                var confFn = new Function ('return ' + confStr);
                conf = confFn();
            }
            for (var prop in conf) {
                if (!conf.hasOwnProperty(prop)) { continue; }
                if (prop in _plugins) {
                    _plugins[prop](conf[prop]);
                } else if (prop === 'runInTag') {
                    _runInTag = conf[prop];
                } else if (prop === 'exposeAPI') {
                    exposeAPI();
                }
            }
        }
    }
    /**
     * Runs through the modules' definition and loads them
     **/
    function initModules (modules) {
        for (var i = 0; i < modules.length; i++) {
            var module = modules[i];
            var moduleSrc = module.getAttribute('data-src');
            moduleSrc && !modules.hasOwnProperty(moduleSrc) && _module(moduleSrc);
            !moduleSrc && module.innerHTML && _moduleSrc({contents: module.innerHTML});
        }
    }
    
    flavour('onLoad', [initConfig, initModules, s6d]);
    var _errCb;
    function s6d (modulePath, cb) {
        if (is(modulePath, 'object')) {
            initConfig([modulePath]);
        } else {
            _module(modulePath, cb, _errCb);
        }
    }
    function exposeAPI () {
        me.s6d = s6d;
        me.s6d.src = function (moduleSrc, cb) {
            _moduleSrc({contents: moduleSrc}, cb, _errCb);
        };
        me.s6d.get = function (moduleName) {
            if (moduleName) {
                return modules[moduleName];
            } else {
                return modules;
            }
        };
        me.s6d.error = function (cb) {
            if (arguments.length === 0) {
                return _errModules;
            }
            _errCb = cb;
        };
        me.s6d.reset = function () {
            _errCb = undefined;
            modules = {};
            _errModules = null;
        };
    }
})(this, harmonyParser, when, flavour);
